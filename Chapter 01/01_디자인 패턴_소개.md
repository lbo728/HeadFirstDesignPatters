# 디자인 패턴 소개

## 소프트웨어 개발에 있어서 바뀌지 않는 것

#### "변화"

애플리케이션을 아무리 잘 디자인해도, 시간이 지남에 따라 점점 성장을 하고 변화되어야 한다.

---

## 1. 문제를 명확하게 하기

> **디자인 원칙**
> 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다.
> "바뀌는 부분은 따로 뽑아서 캡슐화시킨다. 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치치 않은 채로 그 부분만 고치거나 확장할 수 있다."
>
> - 제 1 디자인 원칙

- 코드를 변경하는 과정에서 의도하지 않은 일이 일어나는 것을 줄이면서 시스템의 유연성은 향상시킬 수 있다.
- 모든 패턴은 '시스템의 일부분을 다른 부분과 독립적으로 변화시킬 수 있는' 방법을 제공하기 위한 것이다.

## 2. 바뀌는 부분과 그렇지 않은 부분 분리하기

![01_디자인_패턴_소개-초기 drawio (2)](https://github.com/lbo728/BlockChainStudy/assets/72309817/e4f1635e-4f55-46bd-ae2d-989d6386bd4e)

- 두 개의 클래스 집합(set)을 만들기(Duck 하고는 별개로)
  - 나는 것과 관련된 집합 -> fly()
  - 꽥꽥거리는 것과 관련된 부분 -> quack()

## 3. 오리의 행동 디자인

Duck의 인스턴스에 행동을 할당할 수 있어야함(유연성 확보))

- Duck 클래스에 행동과 관련된 세터(setter) 메소드를 포함 -> 프로그램 실행 중에도 자식 클래스의 행동을 바꿀 수 있음

> **디자인 원칙**
> 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.

1. 각 행동은 인터페이스(예시: FlyBehavior, QuackBehavior)로 **표현**하고, 행동을 구현할 때 이런 인터페이스를 **구현**한다.
2. 특정 행동("삑삑 소리내기"와 같은)만을 목적으로 하는 클래스의 집합 생성 - 이제 나는 행동(fly)와 꽥꽥거리는 행동(quack)은 Duck 클래스에 구현 X
   -> 지금까지 썻떤, 행동을 Duck 클래스에서 구체적으로 구현하거나, 서브클래스 자체에서 별도로 구현하는 방법과 상봔된 방법
   - 그전의 방식들은, 특정 구현에 의존하는 방식

![01_오리의_행동_디자인](https://github.com/lbo728/BlockChainStudy/assets/72309817/5f320991-1999-471f-8cdc-2b0fdbd7ea72)

![01_디자인패턴_인터페이스](https://github.com/lbo728/BlockChainStudy/assets/72309817/974f83e4-9b35-4d68-8950-1864aba633e7)
