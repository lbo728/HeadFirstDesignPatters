# 디자인 패턴 소개

## 소프트웨어 개발에 있어서 바뀌지 않는 것

#### "변화"

애플리케이션을 아무리 잘 디자인해도, 시간이 지남에 따라 점점 성장을 하고 변화되어야 한다.

---

## 1. 문제를 명확하게 하기

> **디자인 원칙**
> 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다.
> "바뀌는 부분은 따로 뽑아서 캡슐화시킨다. 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치치 않은 채로 그 부분만 고치거나 확장할 수 있다."
>
> - 제 1 디자인 원칙

- 코드를 변경하는 과정에서 의도하지 않은 일이 일어나는 것을 줄이면서 시스템의 유연성은 향상시킬 수 있다.
- 모든 패턴은 '시스템의 일부분을 다른 부분과 독립적으로 변화시킬 수 있는' 방법을 제공하기 위한 것이다.

## 2. 바뀌는 부분과 그렇지 않은 부분 분리하기

![01_디자인_패턴_소개-초기 (1)](https://github.com/lbo728/BlockChainStudy/assets/72309817/de74b618-1758-4e30-936a-3c275b83ce73)

- 두 개의 클래스 집합(set)을 만들기(Duck 하고는 별개로)
  - 나는 것과 관련된 집합 -> fly()
  - 꽥꽥거리는 것과 관련된 부분 -> quack()

## 3. 오리의 행동 디자인

Duck의 인스턴스에 행동을 할당할 수 있어야함(유연성 확보))

- Duck 클래스에 행동과 관련된 세터(setter) 메소드를 포함 -> 프로그램 실행 중에도 자식 클래스의 행동을 바꿀 수 있음

> **디자인 원칙**
> 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.

1. 각 행동은 인터페이스(예시: FlyBehavior, QuackBehavior)로 **표현**하고, 행동을 구현할 때 이런 인터페이스를 **구현**한다.
2. 특정 행동("삑삑 소리내기"와 같은)만을 목적으로 하는 클래스의 집합 생성 - 이제 나는 행동(fly)와 꽥꽥거리는 행동(quack)은 Duck 클래스에 구현 X
   -> 지금까지 썻떤, 행동을 Duck 클래스에서 구체적으로 구현하거나, 서브클래스 자체에서 별도로 구현하는 방법과 상봔된 방법
   - 그전의 방식들은, 특정 구현에 의존하는 방식

![01_디자인_패턴_소개-interface (1)](https://github.com/lbo728/BlockChainStudy/assets/72309817/5bc604b4-3a14-4e25-a2ae-3b2324eb1041)

### "인터페이스에 맞춰서 프로그래밍한다"는 사실 "상위 형식에 맞춰서 프로그래밍한다"는 것을 뜻합니다.

- 인터페이스(interface):
  1. 자바의 인터페이스 구조
  2. `인터페이스`라는 개념을 지칭
     -> 핵심은, 객체가 코드에 의해서 고정되지 않도록 어떤 `상위 형식(supertype)`에 맞춰서 프로그래밍함으로써 `다형성`을 활용해야 한다는 것

> **"상위 형식에 맞춰서 프로그래밍하라"**
> 변수를 선언할 때는 보통 추상 클래스나 인터페이스 같은 상위 형식으로 선언해야 한다. 객체를 변수에 대입할 때 상위 형식을 구체적으로 구현한 형식이라면 어떤 객체든 집어넣을 수 있기 떄문이다. 그렇게 하면 변수를 선언하는 클래스에서 실제 객체의 형식을 몰라도 된다

<br>

#### 다형적인 형식을 사용하는 예

![01_디자인_패턴_소개-p50 (1)](https://github.com/lbo728/BlockChainStudy/assets/72309817/189c13ce-76aa-4d50-b9b9-e29dc4a65118)

<br>

##### 1) 구현에 맞춰 프로그래밍을 했을 때

```java
Dog d = new Dog();
d.bar();
```

- 변수 `d`를 Dog 형식(Animal을 확장한 구상 클래스)으로 선언하면 어떤 구체적인 구현에 맞춰 코딩을 해야만 함

<br>

##### 2) 인터페이스/상위 형식에 맞춰서 프로그래밍한 예

```java
Animal animal = new Dog();
animal.makeSound();
```

- Dog이라는 것은 알고 있지만, 다형성을 활용하여 Animal에 대한 레퍼런스를 써도 됨

<br>

##### 3) 구체적으로 구현된 객체를 실행시에 대입하기

```java
a = getAnimal();
a.makeSound();
```

- Animal의 하위 형식 가운데 어떤 형식인지는 모름
- 단지, makeSound()에 대해 올바른 반응을 할 수 있으면 됨

<br>

## 4. Duck의 행동을 구현하는 방법

- 다음과 같이 디자인 하면 다른 형식의 객체에서도 나는 행동과 꽥꽥거리는 행동을 재사용할 수 있음
  - 그런 행동이 더 이상 Duck 클래스 안에 숨겨져 있지 않기 때문
- 또한, 기존의 행동 클래스를 수정하거나 날아다니는 행동을 사용하는 Duck 클래스를 전혀 건드리지 않고도 새로운 행동을 추가할 수 있음

![01_디자인_패턴_소개-p51](https://github.com/lbo728/HeadFirstDesignPatters/assets/72309817/3911c89b-cdd7-4055-809c-2a725b1e1bec)

<br>

## 5. Duck 행동 통합하기

가장 중요한 점은, 이제 Duck에서 '나는 행동'과 '꽥꽥 소리'를 내는 행동을 Duck 클래스(또는 그 서브클래스)에서 정의한 메소드를 써서 구현하지 않고 **다른 클래스에 위임한다는 것**

<br>

1. Duck 클래스에 `flyBehavior`와 `quackBehavior`라는 인터페이스 형식의 인스턴스 변수 추가

- 각 오리 객체에서는 실행 시, 이 변수에 특정 행동 형식(FlyWithWings, Squeak 등)에 대한 레퍼런스를 **다형적으로 설정**
- Duck 클래스 및 모든 서브클래스에서 fly()와 quack() 메소드 제거하며, 대신 `performFly()`와 `performQuack()` 메소드 추가

  <br>

  ![01_디자인_패턴_소개-_p53](https://github.com/lbo728/HeadFirstDesignPatters/assets/72309817/4f0c0420-c4a0-446f-9325-6f86ca5bd6b8)

<br>

2.performQuack()을 구현

```java
public class Duck {
  QuackBehavior quackBehavior; // 모든 Duck에는 QuackBehavior 인터페이스를 구현하는 것에 대한 레퍼런스가 있음

  // 기타 코드...

  public void performQuack() {
    quackBehavior.quack(); // 꽥꽥거리는 행동을 직접 처리하는 대신, quackBehavior로 참조되는 객체에 그 행동을 위임
  }
}
```

<br>

3. `flyBehavior와`와 `quackBehavior`의 **인스턴스 변수를 설정하는 방법**에 대해 생각해보기

```java
  public class MallardDuck extends Duck {
    public MallardDuck() {
      quackBehavior = new Quack(); // MallardDuck에서는 꽥꽥거리는 소리를 처리할 때 Quack 클래스를 사용하기 때문에 performQuack()이 호출되면 꽥꽥거리는 행동은 Quack 객체에게 위임된다. 결과적으로 진짜 꽥꽥거리는 소리를 들을 수 있다.
      flyBehavir = new FlyWithWings();
    }

    public void display() {
      System.out.printIn("저는 물오리입니다");
    }
  }
```

다음과 같이 작성하면, MallardDuck에서는 아무 소리를 내지 못하거나 삑삑 소리만 내는 것이 아닌 진짜 오리가 꽥꽥거리는 소리를 낼 수 있음

- MallardDuck의 인스턴스가 만들어질 때 생성자에서는 Duck으로부터 상속받은 quackBehavior 인스턴스 변수에 `Quack`(**QuackBehavior를 구현한 구상 클래스**)형식의 새로운 인스턴스를 대입함
- 나는 행동에서도 마찬가지

<br>

### Q. 특정 구현에 맞춰서 프로그래밍하지 말라고 했지 않았는가?

앞에 있는 생성자에서 보면 `Quack`이라는, 구현되어 있는 구상 클래스의 인스턴스를 만들었다.

> **답변:**  
> `Quack이`나 `FlyWithWings` 같은 행동 클래스의 인스턴스를 만들어서 행동 레퍼런스 변수에 대입함으로써 행동을 구상 클래스로 설정하고 있긴 하지만, **실행시에 쉽게 변경할 수 있음**  
> 따라서 이 코드는 상당히 유연하다고 할 수 있음
>
> - 인스턴스 변수를 유연하게 초기화 할 수 있는 방법이기 때문
> - `quackBehavior` 인스턴스 변수는 **인터페이스 형식**이기 때문에, (다형성을 활용하여) 실행시에 동적으로 `QuackBehavior`를 구현한 다른 클래스릃 할당할 수 있음
